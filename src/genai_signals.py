from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone

from src.models import Commit, IngestResult

GENAI_ATTRIBUTION_PATTERNS = (
    "co-authored-by: github-actions",
    "generated by",
    "co-authored-by: claude",
    "co-authored-by: chatgpt",
    "co-authored-by: copilot",
    "gpt-",
    "openai",
)

FIXUP_PATTERNS = (
    "fix",
    "bug",
    "typo",
    "oops",
    "correction",
    "update",
    "tweak",
    "adjust",
)


@dataclass(frozen=True)
class GenAISignal:
    name: str
    description: str
    commits: list[str]


@dataclass(frozen=True)
class GenAIReport:
    team: str
    repo_url: str
    genai_signals: list[GenAISignal]
    human_signals: list[GenAISignal]
    summary: str


def analyze_repo(result: IngestResult) -> GenAIReport:
    commits = _sort_commits_by_time(result.commits)
    genai_signals: list[GenAISignal] = []
    human_signals: list[GenAISignal] = []

    large_single = _detect_large_single_commit(commits)
    if large_single is not None:
        genai_signals.append(large_single)

    attributed = _detect_genai_attributed_commit(commits)
    if attributed is not None:
        genai_signals.append(attributed)

    boilerplate = _detect_boilerplate_dump(commits)
    if boilerplate is not None:
        genai_signals.append(boilerplate)

    multiple_authors = _detect_multiple_authors(commits)
    if multiple_authors is not None:
        human_signals.append(multiple_authors)

    iterative = _detect_iterative_commits(commits)
    if iterative is not None:
        human_signals.append(iterative)

    fixups = _detect_fixup_commits(commits)
    if fixups is not None:
        human_signals.append(fixups)

    followup = _detect_followup_on_large_commit(commits)
    if followup is not None:
        human_signals.append(followup)

    summary = _build_summary(genai_signals, human_signals)
    return GenAIReport(
        team=result.spec.team,
        repo_url=result.spec.repo_url,
        genai_signals=genai_signals,
        human_signals=human_signals,
        summary=summary,
    )


def _detect_large_single_commit(commits: list[Commit]) -> GenAISignal | None:
    flagged = [commit.sha for commit in commits if len(commit.files_changed) > 15]
    if not flagged:
        return None
    return GenAISignal(
        name="large_single_commit",
        description="One or more commits touched more than 15 files in a single change.",
        commits=flagged,
    )


def _detect_genai_attributed_commit(commits: list[Commit]) -> GenAISignal | None:
    flagged = []
    for commit in commits:
        message = commit.message.lower()
        if any(pattern in message for pattern in GENAI_ATTRIBUTION_PATTERNS):
            flagged.append(commit.sha)
    if not flagged:
        return None
    return GenAISignal(
        name="genai_attributed_commit",
        description="Commit messages include explicit GenAI attribution patterns.",
        commits=flagged,
    )


def _detect_boilerplate_dump(commits: list[Commit]) -> GenAISignal | None:
    flagged = []
    for index, commit in enumerate(commits):
        if len(commit.files_changed) <= 10:
            continue
        touched_files = set(commit.files_changed)
        subsequent_same_author = [
            later
            for later in commits[index + 1 :]
            if later.author == commit.author and touched_files.intersection(later.files_changed)
        ]
        if not subsequent_same_author:
            flagged.append(commit.sha)
    if not flagged:
        return None
    return GenAISignal(
        name="boilerplate_dump",
        description=(
            "Large file additions had no later same-author commits on those files, "
            "which may indicate low follow-up engagement."
        ),
        commits=flagged,
    )


def _detect_multiple_authors(commits: list[Commit]) -> GenAISignal | None:
    author_set = {commit.author.strip().lower() for commit in commits if commit.author.strip()}
    if len(author_set) <= 1:
        return None
    return GenAISignal(
        name="multiple_authors",
        description="More than one author contributed commits.",
        commits=[commit.sha for commit in commits],
    )


def _detect_iterative_commits(commits: list[Commit]) -> GenAISignal | None:
    file_touch_counts: dict[str, int] = {}
    for commit in commits:
        for path in commit.files_changed:
            file_touch_counts[path] = file_touch_counts.get(path, 0) + 1

    iterative_files = {path for path, count in file_touch_counts.items() if count > 3}
    if not iterative_files:
        return None

    flagged = [
        commit.sha
        for commit in commits
        if any(path in iterative_files for path in commit.files_changed)
    ]
    return GenAISignal(
        name="iterative_commits",
        description="Files were revised across more than 3 commits, indicating iterative work.",
        commits=flagged,
    )


def _detect_fixup_commits(commits: list[Commit]) -> GenAISignal | None:
    flagged = []
    for commit in commits:
        message = commit.message.lower()
        if any(pattern in message for pattern in FIXUP_PATTERNS):
            flagged.append(commit.sha)
    if not flagged:
        return None
    return GenAISignal(
        name="fixup_commits",
        description="Commit messages suggest debugging or fixup activity.",
        commits=flagged,
    )


def _detect_followup_on_large_commit(commits: list[Commit]) -> GenAISignal | None:
    flagged = []
    for index, commit in enumerate(commits):
        if len(commit.files_changed) <= 10:
            continue
        touched_files = set(commit.files_changed)
        followups = 0
        for later in commits[index + 1 :]:
            if len(later.files_changed) > 10:
                continue
            if touched_files.intersection(later.files_changed):
                followups += 1
        if followups >= 2:
            flagged.append(commit.sha)

    if not flagged:
        return None
    return GenAISignal(
        name="followup_on_large_commit",
        description="Large commits were followed by at least two smaller commits on the same files.",
        commits=flagged,
    )


def _build_summary(genai_signals: list[GenAISignal], human_signals: list[GenAISignal]) -> str:
    if not genai_signals:
        return "No GenAI usage signals detected."
    if human_signals:
        return "GenAI usage detected with evidence of human review."
    return "GenAI usage detected with limited evidence of human engagement."


def _sort_commits_by_time(commits: list[Commit]) -> list[Commit]:
    return sorted(
        commits,
        key=lambda commit: _parse_commit_time(commit.timestamp),
    )


def _parse_commit_time(timestamp: str) -> datetime:
    if not timestamp:
        return datetime.min.replace(tzinfo=timezone.utc)
    parsed = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
    if parsed.tzinfo is None:
        return parsed.replace(tzinfo=timezone.utc)
    return parsed.astimezone(timezone.utc)
